Grammar:

Rule 0     S' -> prog
Rule 1     prog -> listeInstructions
Rule 2     listeInstructions -> instruction listeInstructions
Rule 3     listeInstructions -> instruction
Rule 4     instruction -> type IDENTIFIANT ( listeParamsOpt ) bloc
Rule 5     instruction -> IDENTIFIANT ( listeArgsOpt ) ;
Rule 6     instruction -> RETOURNER expr ;
Rule 7     instruction -> TANTQUE ( expr ) bloc
Rule 8     instruction -> SI ( expr ) bloc SINON bloc
Rule 9     instruction -> SI ( expr ) bloc
Rule 10    instruction -> type IDENTIFIANT = expr ;
Rule 11    instruction -> IDENTIFIANT = expr ;
Rule 12    instruction -> type IDENTIFIANT ;
Rule 13    instruction -> ECRIRE ( CHAINE ) ;
Rule 14    instruction -> ECRIRE ( expr ) ;
Rule 15    expr -> expr_ou
Rule 16    expr_ou -> expr_et
Rule 17    expr_ou -> expr_ou OU expr_et
Rule 18    expr_et -> expr_non
Rule 19    expr_et -> expr_et ET expr_non
Rule 20    expr_non -> expr_comp
Rule 21    expr_non -> NON expr_non
Rule 22    expr_comp -> expr_add
Rule 23    expr_comp -> expr_comp SUPERIEUR_OU_EGAL expr_add
Rule 24    expr_comp -> expr_comp INFERIEUR_OU_EGAL expr_add
Rule 25    expr_comp -> expr_comp > expr_add
Rule 26    expr_comp -> expr_comp < expr_add
Rule 27    expr_comp -> expr_comp DIFFERENT expr_add
Rule 28    expr_comp -> expr_comp EGAL_EGAL expr_add
Rule 29    expr_add -> expr_mult
Rule 30    expr_add -> expr_add - expr_mult
Rule 31    expr_add -> expr_add + expr_mult
Rule 32    expr_mult -> expr_unaire
Rule 33    expr_mult -> expr_mult % expr_unaire
Rule 34    expr_mult -> expr_mult / expr_unaire
Rule 35    expr_mult -> expr_mult * expr_unaire
Rule 36    expr_unaire -> expr_primaire
Rule 37    expr_unaire -> - expr_unaire
Rule 38    expr_primaire -> IDENTIFIANT ( listeArgsOpt )
Rule 39    expr_primaire -> LIRE ( )
Rule 40    expr_primaire -> IDENTIFIANT
Rule 41    expr_primaire -> FAUX
Rule 42    expr_primaire -> VRAI
Rule 43    expr_primaire -> ENTIER
Rule 44    expr_primaire -> ( expr )
Rule 45    type -> BOOLEEN_TYPE
Rule 46    type -> ENTIER_TYPE
Rule 47    bloc -> { listeInstructions }
Rule 48    listeArgs -> listeArgs , expr
Rule 49    listeArgs -> expr
Rule 50    listeArgsOpt -> listeArgs
Rule 51    listeArgsOpt -> <empty>
Rule 52    listeParamsOpt -> listeParams
Rule 53    listeParamsOpt -> <empty>
Rule 54    listeParams -> listeParams , type IDENTIFIANT
Rule 55    listeParams -> type IDENTIFIANT

Unused terminals:

    FONCTION

Terminals, with rules where they appear:

%                    : 33
(                    : 4 5 7 8 9 13 14 38 39 44
)                    : 4 5 7 8 9 13 14 38 39 44
*                    : 35
+                    : 31
,                    : 48 54
-                    : 30 37
/                    : 34
;                    : 5 6 10 11 12 13 14
<                    : 26
=                    : 10 11
>                    : 25
BOOLEEN_TYPE         : 45
CHAINE               : 13
DIFFERENT            : 27
ECRIRE               : 13 14
EGAL_EGAL            : 28
ENTIER               : 43
ENTIER_TYPE          : 46
ET                   : 19
FAUX                 : 41
FONCTION             : 
IDENTIFIANT          : 4 5 10 11 12 38 40 54 55
INFERIEUR_OU_EGAL    : 24
LIRE                 : 39
NON                  : 21
OU                   : 17
RETOURNER            : 6
SI                   : 8 9
SINON                : 8
SUPERIEUR_OU_EGAL    : 23
TANTQUE              : 7
VRAI                 : 42
error                : 
{                    : 47
}                    : 47

Nonterminals, with rules where they appear:

bloc                 : 4 7 8 8 9
expr                 : 6 7 8 9 10 11 14 44 48 49
expr_add             : 22 23 24 25 26 27 28 30 31
expr_comp            : 20 23 24 25 26 27 28
expr_et              : 16 17 19
expr_mult            : 29 30 31 33 34 35
expr_non             : 18 19 21
expr_ou              : 15 17
expr_primaire        : 36
expr_unaire          : 32 33 34 35 37
instruction          : 2 3
listeArgs            : 48 50
listeArgsOpt         : 5 38
listeInstructions    : 1 2 47
listeParams          : 52 54
listeParamsOpt       : 4
prog                 : 0
type                 : 4 10 12 54 55


state 0

    (0) S' -> . prog
    (1) prog -> . listeInstructions
    (2) listeInstructions -> . instruction listeInstructions
    (3) listeInstructions -> . instruction
    (4) instruction -> . type IDENTIFIANT ( listeParamsOpt ) bloc
    (5) instruction -> . IDENTIFIANT ( listeArgsOpt ) ;
    (6) instruction -> . RETOURNER expr ;
    (7) instruction -> . TANTQUE ( expr ) bloc
    (8) instruction -> . SI ( expr ) bloc SINON bloc
    (9) instruction -> . SI ( expr ) bloc
    (10) instruction -> . type IDENTIFIANT = expr ;
    (11) instruction -> . IDENTIFIANT = expr ;
    (12) instruction -> . type IDENTIFIANT ;
    (13) instruction -> . ECRIRE ( CHAINE ) ;
    (14) instruction -> . ECRIRE ( expr ) ;
    (45) type -> . BOOLEEN_TYPE
    (46) type -> . ENTIER_TYPE
    IDENTIFIANT     shift and go to state 5
    RETOURNER       shift and go to state 6
    TANTQUE         shift and go to state 7
    SI              shift and go to state 8
    ECRIRE          shift and go to state 9
    BOOLEEN_TYPE    shift and go to state 10
    ENTIER_TYPE     shift and go to state 11

    prog                           shift and go to state 1
    listeInstructions              shift and go to state 2
    instruction                    shift and go to state 3
    type                           shift and go to state 4

state 1

    (0) S' -> prog .


state 2

    (1) prog -> listeInstructions .
    $end            reduce using rule 1 (prog -> listeInstructions .)


state 3

    (2) listeInstructions -> instruction . listeInstructions
    (3) listeInstructions -> instruction .
    (2) listeInstructions -> . instruction listeInstructions
    (3) listeInstructions -> . instruction
    (4) instruction -> . type IDENTIFIANT ( listeParamsOpt ) bloc
    (5) instruction -> . IDENTIFIANT ( listeArgsOpt ) ;
    (6) instruction -> . RETOURNER expr ;
    (7) instruction -> . TANTQUE ( expr ) bloc
    (8) instruction -> . SI ( expr ) bloc SINON bloc
    (9) instruction -> . SI ( expr ) bloc
    (10) instruction -> . type IDENTIFIANT = expr ;
    (11) instruction -> . IDENTIFIANT = expr ;
    (12) instruction -> . type IDENTIFIANT ;
    (13) instruction -> . ECRIRE ( CHAINE ) ;
    (14) instruction -> . ECRIRE ( expr ) ;
    (45) type -> . BOOLEEN_TYPE
    (46) type -> . ENTIER_TYPE
    $end            reduce using rule 3 (listeInstructions -> instruction .)
    }               reduce using rule 3 (listeInstructions -> instruction .)
    IDENTIFIANT     shift and go to state 5
    RETOURNER       shift and go to state 6
    TANTQUE         shift and go to state 7
    SI              shift and go to state 8
    ECRIRE          shift and go to state 9
    BOOLEEN_TYPE    shift and go to state 10
    ENTIER_TYPE     shift and go to state 11

    instruction                    shift and go to state 3
    listeInstructions              shift and go to state 12
    type                           shift and go to state 4

state 4

    (4) instruction -> type . IDENTIFIANT ( listeParamsOpt ) bloc
    (10) instruction -> type . IDENTIFIANT = expr ;
    (12) instruction -> type . IDENTIFIANT ;
    IDENTIFIANT     shift and go to state 13


state 5

    (5) instruction -> IDENTIFIANT . ( listeArgsOpt ) ;
    (11) instruction -> IDENTIFIANT . = expr ;
    (               shift and go to state 14
    =               shift and go to state 15


state 6

    (6) instruction -> RETOURNER . expr ;
    (15) expr -> . expr_ou
    (16) expr_ou -> . expr_et
    (17) expr_ou -> . expr_ou OU expr_et
    (18) expr_et -> . expr_non
    (19) expr_et -> . expr_et ET expr_non
    (20) expr_non -> . expr_comp
    (21) expr_non -> . NON expr_non
    (22) expr_comp -> . expr_add
    (23) expr_comp -> . expr_comp SUPERIEUR_OU_EGAL expr_add
    (24) expr_comp -> . expr_comp INFERIEUR_OU_EGAL expr_add
    (25) expr_comp -> . expr_comp > expr_add
    (26) expr_comp -> . expr_comp < expr_add
    (27) expr_comp -> . expr_comp DIFFERENT expr_add
    (28) expr_comp -> . expr_comp EGAL_EGAL expr_add
    (29) expr_add -> . expr_mult
    (30) expr_add -> . expr_add - expr_mult
    (31) expr_add -> . expr_add + expr_mult
    (32) expr_mult -> . expr_unaire
    (33) expr_mult -> . expr_mult % expr_unaire
    (34) expr_mult -> . expr_mult / expr_unaire
    (35) expr_mult -> . expr_mult * expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    NON             shift and go to state 21
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr                           shift and go to state 16
    expr_ou                        shift and go to state 17
    expr_et                        shift and go to state 18
    expr_non                       shift and go to state 19
    expr_comp                      shift and go to state 20
    expr_add                       shift and go to state 22
    expr_mult                      shift and go to state 23
    expr_unaire                    shift and go to state 25
    expr_primaire                  shift and go to state 26

state 7

    (7) instruction -> TANTQUE . ( expr ) bloc
    (               shift and go to state 33


state 8

    (8) instruction -> SI . ( expr ) bloc SINON bloc
    (9) instruction -> SI . ( expr ) bloc
    (               shift and go to state 34


state 9

    (13) instruction -> ECRIRE . ( CHAINE ) ;
    (14) instruction -> ECRIRE . ( expr ) ;
    (               shift and go to state 35


state 10

    (45) type -> BOOLEEN_TYPE .
    IDENTIFIANT     reduce using rule 45 (type -> BOOLEEN_TYPE .)


state 11

    (46) type -> ENTIER_TYPE .
    IDENTIFIANT     reduce using rule 46 (type -> ENTIER_TYPE .)


state 12

    (2) listeInstructions -> instruction listeInstructions .
    $end            reduce using rule 2 (listeInstructions -> instruction listeInstructions .)
    }               reduce using rule 2 (listeInstructions -> instruction listeInstructions .)


state 13

    (4) instruction -> type IDENTIFIANT . ( listeParamsOpt ) bloc
    (10) instruction -> type IDENTIFIANT . = expr ;
    (12) instruction -> type IDENTIFIANT . ;
    (               shift and go to state 36
    =               shift and go to state 37
    ;               shift and go to state 38


state 14

    (5) instruction -> IDENTIFIANT ( . listeArgsOpt ) ;
    (50) listeArgsOpt -> . listeArgs
    (51) listeArgsOpt -> .
    (48) listeArgs -> . listeArgs , expr
    (49) listeArgs -> . expr
    (15) expr -> . expr_ou
    (16) expr_ou -> . expr_et
    (17) expr_ou -> . expr_ou OU expr_et
    (18) expr_et -> . expr_non
    (19) expr_et -> . expr_et ET expr_non
    (20) expr_non -> . expr_comp
    (21) expr_non -> . NON expr_non
    (22) expr_comp -> . expr_add
    (23) expr_comp -> . expr_comp SUPERIEUR_OU_EGAL expr_add
    (24) expr_comp -> . expr_comp INFERIEUR_OU_EGAL expr_add
    (25) expr_comp -> . expr_comp > expr_add
    (26) expr_comp -> . expr_comp < expr_add
    (27) expr_comp -> . expr_comp DIFFERENT expr_add
    (28) expr_comp -> . expr_comp EGAL_EGAL expr_add
    (29) expr_add -> . expr_mult
    (30) expr_add -> . expr_add - expr_mult
    (31) expr_add -> . expr_add + expr_mult
    (32) expr_mult -> . expr_unaire
    (33) expr_mult -> . expr_mult % expr_unaire
    (34) expr_mult -> . expr_mult / expr_unaire
    (35) expr_mult -> . expr_mult * expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    )               reduce using rule 51 (listeArgsOpt -> .)
    NON             shift and go to state 21
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    listeArgsOpt                   shift and go to state 39
    listeArgs                      shift and go to state 40
    expr                           shift and go to state 41
    expr_ou                        shift and go to state 17
    expr_et                        shift and go to state 18
    expr_non                       shift and go to state 19
    expr_comp                      shift and go to state 20
    expr_add                       shift and go to state 22
    expr_mult                      shift and go to state 23
    expr_unaire                    shift and go to state 25
    expr_primaire                  shift and go to state 26

state 15

    (11) instruction -> IDENTIFIANT = . expr ;
    (15) expr -> . expr_ou
    (16) expr_ou -> . expr_et
    (17) expr_ou -> . expr_ou OU expr_et
    (18) expr_et -> . expr_non
    (19) expr_et -> . expr_et ET expr_non
    (20) expr_non -> . expr_comp
    (21) expr_non -> . NON expr_non
    (22) expr_comp -> . expr_add
    (23) expr_comp -> . expr_comp SUPERIEUR_OU_EGAL expr_add
    (24) expr_comp -> . expr_comp INFERIEUR_OU_EGAL expr_add
    (25) expr_comp -> . expr_comp > expr_add
    (26) expr_comp -> . expr_comp < expr_add
    (27) expr_comp -> . expr_comp DIFFERENT expr_add
    (28) expr_comp -> . expr_comp EGAL_EGAL expr_add
    (29) expr_add -> . expr_mult
    (30) expr_add -> . expr_add - expr_mult
    (31) expr_add -> . expr_add + expr_mult
    (32) expr_mult -> . expr_unaire
    (33) expr_mult -> . expr_mult % expr_unaire
    (34) expr_mult -> . expr_mult / expr_unaire
    (35) expr_mult -> . expr_mult * expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    NON             shift and go to state 21
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr                           shift and go to state 42
    expr_ou                        shift and go to state 17
    expr_et                        shift and go to state 18
    expr_non                       shift and go to state 19
    expr_comp                      shift and go to state 20
    expr_add                       shift and go to state 22
    expr_mult                      shift and go to state 23
    expr_unaire                    shift and go to state 25
    expr_primaire                  shift and go to state 26

state 16

    (6) instruction -> RETOURNER expr . ;
    ;               shift and go to state 43


state 17

    (15) expr -> expr_ou .
    (17) expr_ou -> expr_ou . OU expr_et
    ;               reduce using rule 15 (expr -> expr_ou .)
    ,               reduce using rule 15 (expr -> expr_ou .)
    )               reduce using rule 15 (expr -> expr_ou .)
    OU              shift and go to state 44


state 18

    (16) expr_ou -> expr_et .
    (19) expr_et -> expr_et . ET expr_non
    OU              reduce using rule 16 (expr_ou -> expr_et .)
    ;               reduce using rule 16 (expr_ou -> expr_et .)
    ,               reduce using rule 16 (expr_ou -> expr_et .)
    )               reduce using rule 16 (expr_ou -> expr_et .)
    ET              shift and go to state 45


state 19

    (18) expr_et -> expr_non .
    ET              reduce using rule 18 (expr_et -> expr_non .)
    OU              reduce using rule 18 (expr_et -> expr_non .)
    ;               reduce using rule 18 (expr_et -> expr_non .)
    ,               reduce using rule 18 (expr_et -> expr_non .)
    )               reduce using rule 18 (expr_et -> expr_non .)


state 20

    (20) expr_non -> expr_comp .
    (23) expr_comp -> expr_comp . SUPERIEUR_OU_EGAL expr_add
    (24) expr_comp -> expr_comp . INFERIEUR_OU_EGAL expr_add
    (25) expr_comp -> expr_comp . > expr_add
    (26) expr_comp -> expr_comp . < expr_add
    (27) expr_comp -> expr_comp . DIFFERENT expr_add
    (28) expr_comp -> expr_comp . EGAL_EGAL expr_add
    ET              reduce using rule 20 (expr_non -> expr_comp .)
    OU              reduce using rule 20 (expr_non -> expr_comp .)
    ;               reduce using rule 20 (expr_non -> expr_comp .)
    ,               reduce using rule 20 (expr_non -> expr_comp .)
    )               reduce using rule 20 (expr_non -> expr_comp .)
    SUPERIEUR_OU_EGAL shift and go to state 46
    INFERIEUR_OU_EGAL shift and go to state 47
    >               shift and go to state 48
    <               shift and go to state 49
    DIFFERENT       shift and go to state 50
    EGAL_EGAL       shift and go to state 51


state 21

    (21) expr_non -> NON . expr_non
    (20) expr_non -> . expr_comp
    (21) expr_non -> . NON expr_non
    (22) expr_comp -> . expr_add
    (23) expr_comp -> . expr_comp SUPERIEUR_OU_EGAL expr_add
    (24) expr_comp -> . expr_comp INFERIEUR_OU_EGAL expr_add
    (25) expr_comp -> . expr_comp > expr_add
    (26) expr_comp -> . expr_comp < expr_add
    (27) expr_comp -> . expr_comp DIFFERENT expr_add
    (28) expr_comp -> . expr_comp EGAL_EGAL expr_add
    (29) expr_add -> . expr_mult
    (30) expr_add -> . expr_add - expr_mult
    (31) expr_add -> . expr_add + expr_mult
    (32) expr_mult -> . expr_unaire
    (33) expr_mult -> . expr_mult % expr_unaire
    (34) expr_mult -> . expr_mult / expr_unaire
    (35) expr_mult -> . expr_mult * expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    NON             shift and go to state 21
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr_non                       shift and go to state 52
    expr_comp                      shift and go to state 20
    expr_add                       shift and go to state 22
    expr_mult                      shift and go to state 23
    expr_unaire                    shift and go to state 25
    expr_primaire                  shift and go to state 26

state 22

    (22) expr_comp -> expr_add .
    (30) expr_add -> expr_add . - expr_mult
    (31) expr_add -> expr_add . + expr_mult
    SUPERIEUR_OU_EGAL reduce using rule 22 (expr_comp -> expr_add .)
    INFERIEUR_OU_EGAL reduce using rule 22 (expr_comp -> expr_add .)
    >               reduce using rule 22 (expr_comp -> expr_add .)
    <               reduce using rule 22 (expr_comp -> expr_add .)
    DIFFERENT       reduce using rule 22 (expr_comp -> expr_add .)
    EGAL_EGAL       reduce using rule 22 (expr_comp -> expr_add .)
    ET              reduce using rule 22 (expr_comp -> expr_add .)
    OU              reduce using rule 22 (expr_comp -> expr_add .)
    ;               reduce using rule 22 (expr_comp -> expr_add .)
    ,               reduce using rule 22 (expr_comp -> expr_add .)
    )               reduce using rule 22 (expr_comp -> expr_add .)
    -               shift and go to state 53
    +               shift and go to state 54


state 23

    (29) expr_add -> expr_mult .
    (33) expr_mult -> expr_mult . % expr_unaire
    (34) expr_mult -> expr_mult . / expr_unaire
    (35) expr_mult -> expr_mult . * expr_unaire
    -               reduce using rule 29 (expr_add -> expr_mult .)
    +               reduce using rule 29 (expr_add -> expr_mult .)
    SUPERIEUR_OU_EGAL reduce using rule 29 (expr_add -> expr_mult .)
    INFERIEUR_OU_EGAL reduce using rule 29 (expr_add -> expr_mult .)
    >               reduce using rule 29 (expr_add -> expr_mult .)
    <               reduce using rule 29 (expr_add -> expr_mult .)
    DIFFERENT       reduce using rule 29 (expr_add -> expr_mult .)
    EGAL_EGAL       reduce using rule 29 (expr_add -> expr_mult .)
    ET              reduce using rule 29 (expr_add -> expr_mult .)
    OU              reduce using rule 29 (expr_add -> expr_mult .)
    ;               reduce using rule 29 (expr_add -> expr_mult .)
    ,               reduce using rule 29 (expr_add -> expr_mult .)
    )               reduce using rule 29 (expr_add -> expr_mult .)
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57


state 24

    (37) expr_unaire -> - . expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr_unaire                    shift and go to state 58
    expr_primaire                  shift and go to state 26

state 25

    (32) expr_mult -> expr_unaire .
    %               reduce using rule 32 (expr_mult -> expr_unaire .)
    /               reduce using rule 32 (expr_mult -> expr_unaire .)
    *               reduce using rule 32 (expr_mult -> expr_unaire .)
    -               reduce using rule 32 (expr_mult -> expr_unaire .)
    +               reduce using rule 32 (expr_mult -> expr_unaire .)
    SUPERIEUR_OU_EGAL reduce using rule 32 (expr_mult -> expr_unaire .)
    INFERIEUR_OU_EGAL reduce using rule 32 (expr_mult -> expr_unaire .)
    >               reduce using rule 32 (expr_mult -> expr_unaire .)
    <               reduce using rule 32 (expr_mult -> expr_unaire .)
    DIFFERENT       reduce using rule 32 (expr_mult -> expr_unaire .)
    EGAL_EGAL       reduce using rule 32 (expr_mult -> expr_unaire .)
    ET              reduce using rule 32 (expr_mult -> expr_unaire .)
    OU              reduce using rule 32 (expr_mult -> expr_unaire .)
    ;               reduce using rule 32 (expr_mult -> expr_unaire .)
    ,               reduce using rule 32 (expr_mult -> expr_unaire .)
    )               reduce using rule 32 (expr_mult -> expr_unaire .)


state 26

    (36) expr_unaire -> expr_primaire .
    %               reduce using rule 36 (expr_unaire -> expr_primaire .)
    /               reduce using rule 36 (expr_unaire -> expr_primaire .)
    *               reduce using rule 36 (expr_unaire -> expr_primaire .)
    -               reduce using rule 36 (expr_unaire -> expr_primaire .)
    +               reduce using rule 36 (expr_unaire -> expr_primaire .)
    SUPERIEUR_OU_EGAL reduce using rule 36 (expr_unaire -> expr_primaire .)
    INFERIEUR_OU_EGAL reduce using rule 36 (expr_unaire -> expr_primaire .)
    >               reduce using rule 36 (expr_unaire -> expr_primaire .)
    <               reduce using rule 36 (expr_unaire -> expr_primaire .)
    DIFFERENT       reduce using rule 36 (expr_unaire -> expr_primaire .)
    EGAL_EGAL       reduce using rule 36 (expr_unaire -> expr_primaire .)
    ET              reduce using rule 36 (expr_unaire -> expr_primaire .)
    OU              reduce using rule 36 (expr_unaire -> expr_primaire .)
    ;               reduce using rule 36 (expr_unaire -> expr_primaire .)
    ,               reduce using rule 36 (expr_unaire -> expr_primaire .)
    )               reduce using rule 36 (expr_unaire -> expr_primaire .)


state 27

    (38) expr_primaire -> IDENTIFIANT . ( listeArgsOpt )
    (40) expr_primaire -> IDENTIFIANT .
    (               shift and go to state 59
    %               reduce using rule 40 (expr_primaire -> IDENTIFIANT .)
    /               reduce using rule 40 (expr_primaire -> IDENTIFIANT .)
    *               reduce using rule 40 (expr_primaire -> IDENTIFIANT .)
    -               reduce using rule 40 (expr_primaire -> IDENTIFIANT .)
    +               reduce using rule 40 (expr_primaire -> IDENTIFIANT .)
    SUPERIEUR_OU_EGAL reduce using rule 40 (expr_primaire -> IDENTIFIANT .)
    INFERIEUR_OU_EGAL reduce using rule 40 (expr_primaire -> IDENTIFIANT .)
    >               reduce using rule 40 (expr_primaire -> IDENTIFIANT .)
    <               reduce using rule 40 (expr_primaire -> IDENTIFIANT .)
    DIFFERENT       reduce using rule 40 (expr_primaire -> IDENTIFIANT .)
    EGAL_EGAL       reduce using rule 40 (expr_primaire -> IDENTIFIANT .)
    ET              reduce using rule 40 (expr_primaire -> IDENTIFIANT .)
    OU              reduce using rule 40 (expr_primaire -> IDENTIFIANT .)
    ;               reduce using rule 40 (expr_primaire -> IDENTIFIANT .)
    ,               reduce using rule 40 (expr_primaire -> IDENTIFIANT .)
    )               reduce using rule 40 (expr_primaire -> IDENTIFIANT .)


state 28

    (44) expr_primaire -> ( . expr )
    (15) expr -> . expr_ou
    (16) expr_ou -> . expr_et
    (17) expr_ou -> . expr_ou OU expr_et
    (18) expr_et -> . expr_non
    (19) expr_et -> . expr_et ET expr_non
    (20) expr_non -> . expr_comp
    (21) expr_non -> . NON expr_non
    (22) expr_comp -> . expr_add
    (23) expr_comp -> . expr_comp SUPERIEUR_OU_EGAL expr_add
    (24) expr_comp -> . expr_comp INFERIEUR_OU_EGAL expr_add
    (25) expr_comp -> . expr_comp > expr_add
    (26) expr_comp -> . expr_comp < expr_add
    (27) expr_comp -> . expr_comp DIFFERENT expr_add
    (28) expr_comp -> . expr_comp EGAL_EGAL expr_add
    (29) expr_add -> . expr_mult
    (30) expr_add -> . expr_add - expr_mult
    (31) expr_add -> . expr_add + expr_mult
    (32) expr_mult -> . expr_unaire
    (33) expr_mult -> . expr_mult % expr_unaire
    (34) expr_mult -> . expr_mult / expr_unaire
    (35) expr_mult -> . expr_mult * expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    NON             shift and go to state 21
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr                           shift and go to state 60
    expr_ou                        shift and go to state 17
    expr_et                        shift and go to state 18
    expr_non                       shift and go to state 19
    expr_comp                      shift and go to state 20
    expr_add                       shift and go to state 22
    expr_mult                      shift and go to state 23
    expr_unaire                    shift and go to state 25
    expr_primaire                  shift and go to state 26

state 29

    (39) expr_primaire -> LIRE . ( )
    (               shift and go to state 61


state 30

    (41) expr_primaire -> FAUX .
    %               reduce using rule 41 (expr_primaire -> FAUX .)
    /               reduce using rule 41 (expr_primaire -> FAUX .)
    *               reduce using rule 41 (expr_primaire -> FAUX .)
    -               reduce using rule 41 (expr_primaire -> FAUX .)
    +               reduce using rule 41 (expr_primaire -> FAUX .)
    SUPERIEUR_OU_EGAL reduce using rule 41 (expr_primaire -> FAUX .)
    INFERIEUR_OU_EGAL reduce using rule 41 (expr_primaire -> FAUX .)
    >               reduce using rule 41 (expr_primaire -> FAUX .)
    <               reduce using rule 41 (expr_primaire -> FAUX .)
    DIFFERENT       reduce using rule 41 (expr_primaire -> FAUX .)
    EGAL_EGAL       reduce using rule 41 (expr_primaire -> FAUX .)
    ET              reduce using rule 41 (expr_primaire -> FAUX .)
    OU              reduce using rule 41 (expr_primaire -> FAUX .)
    ;               reduce using rule 41 (expr_primaire -> FAUX .)
    ,               reduce using rule 41 (expr_primaire -> FAUX .)
    )               reduce using rule 41 (expr_primaire -> FAUX .)


state 31

    (42) expr_primaire -> VRAI .
    %               reduce using rule 42 (expr_primaire -> VRAI .)
    /               reduce using rule 42 (expr_primaire -> VRAI .)
    *               reduce using rule 42 (expr_primaire -> VRAI .)
    -               reduce using rule 42 (expr_primaire -> VRAI .)
    +               reduce using rule 42 (expr_primaire -> VRAI .)
    SUPERIEUR_OU_EGAL reduce using rule 42 (expr_primaire -> VRAI .)
    INFERIEUR_OU_EGAL reduce using rule 42 (expr_primaire -> VRAI .)
    >               reduce using rule 42 (expr_primaire -> VRAI .)
    <               reduce using rule 42 (expr_primaire -> VRAI .)
    DIFFERENT       reduce using rule 42 (expr_primaire -> VRAI .)
    EGAL_EGAL       reduce using rule 42 (expr_primaire -> VRAI .)
    ET              reduce using rule 42 (expr_primaire -> VRAI .)
    OU              reduce using rule 42 (expr_primaire -> VRAI .)
    ;               reduce using rule 42 (expr_primaire -> VRAI .)
    ,               reduce using rule 42 (expr_primaire -> VRAI .)
    )               reduce using rule 42 (expr_primaire -> VRAI .)


state 32

    (43) expr_primaire -> ENTIER .
    %               reduce using rule 43 (expr_primaire -> ENTIER .)
    /               reduce using rule 43 (expr_primaire -> ENTIER .)
    *               reduce using rule 43 (expr_primaire -> ENTIER .)
    -               reduce using rule 43 (expr_primaire -> ENTIER .)
    +               reduce using rule 43 (expr_primaire -> ENTIER .)
    SUPERIEUR_OU_EGAL reduce using rule 43 (expr_primaire -> ENTIER .)
    INFERIEUR_OU_EGAL reduce using rule 43 (expr_primaire -> ENTIER .)
    >               reduce using rule 43 (expr_primaire -> ENTIER .)
    <               reduce using rule 43 (expr_primaire -> ENTIER .)
    DIFFERENT       reduce using rule 43 (expr_primaire -> ENTIER .)
    EGAL_EGAL       reduce using rule 43 (expr_primaire -> ENTIER .)
    ET              reduce using rule 43 (expr_primaire -> ENTIER .)
    OU              reduce using rule 43 (expr_primaire -> ENTIER .)
    ;               reduce using rule 43 (expr_primaire -> ENTIER .)
    ,               reduce using rule 43 (expr_primaire -> ENTIER .)
    )               reduce using rule 43 (expr_primaire -> ENTIER .)


state 33

    (7) instruction -> TANTQUE ( . expr ) bloc
    (15) expr -> . expr_ou
    (16) expr_ou -> . expr_et
    (17) expr_ou -> . expr_ou OU expr_et
    (18) expr_et -> . expr_non
    (19) expr_et -> . expr_et ET expr_non
    (20) expr_non -> . expr_comp
    (21) expr_non -> . NON expr_non
    (22) expr_comp -> . expr_add
    (23) expr_comp -> . expr_comp SUPERIEUR_OU_EGAL expr_add
    (24) expr_comp -> . expr_comp INFERIEUR_OU_EGAL expr_add
    (25) expr_comp -> . expr_comp > expr_add
    (26) expr_comp -> . expr_comp < expr_add
    (27) expr_comp -> . expr_comp DIFFERENT expr_add
    (28) expr_comp -> . expr_comp EGAL_EGAL expr_add
    (29) expr_add -> . expr_mult
    (30) expr_add -> . expr_add - expr_mult
    (31) expr_add -> . expr_add + expr_mult
    (32) expr_mult -> . expr_unaire
    (33) expr_mult -> . expr_mult % expr_unaire
    (34) expr_mult -> . expr_mult / expr_unaire
    (35) expr_mult -> . expr_mult * expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    NON             shift and go to state 21
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr                           shift and go to state 62
    expr_ou                        shift and go to state 17
    expr_et                        shift and go to state 18
    expr_non                       shift and go to state 19
    expr_comp                      shift and go to state 20
    expr_add                       shift and go to state 22
    expr_mult                      shift and go to state 23
    expr_unaire                    shift and go to state 25
    expr_primaire                  shift and go to state 26

state 34

    (8) instruction -> SI ( . expr ) bloc SINON bloc
    (9) instruction -> SI ( . expr ) bloc
    (15) expr -> . expr_ou
    (16) expr_ou -> . expr_et
    (17) expr_ou -> . expr_ou OU expr_et
    (18) expr_et -> . expr_non
    (19) expr_et -> . expr_et ET expr_non
    (20) expr_non -> . expr_comp
    (21) expr_non -> . NON expr_non
    (22) expr_comp -> . expr_add
    (23) expr_comp -> . expr_comp SUPERIEUR_OU_EGAL expr_add
    (24) expr_comp -> . expr_comp INFERIEUR_OU_EGAL expr_add
    (25) expr_comp -> . expr_comp > expr_add
    (26) expr_comp -> . expr_comp < expr_add
    (27) expr_comp -> . expr_comp DIFFERENT expr_add
    (28) expr_comp -> . expr_comp EGAL_EGAL expr_add
    (29) expr_add -> . expr_mult
    (30) expr_add -> . expr_add - expr_mult
    (31) expr_add -> . expr_add + expr_mult
    (32) expr_mult -> . expr_unaire
    (33) expr_mult -> . expr_mult % expr_unaire
    (34) expr_mult -> . expr_mult / expr_unaire
    (35) expr_mult -> . expr_mult * expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    NON             shift and go to state 21
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr                           shift and go to state 63
    expr_ou                        shift and go to state 17
    expr_et                        shift and go to state 18
    expr_non                       shift and go to state 19
    expr_comp                      shift and go to state 20
    expr_add                       shift and go to state 22
    expr_mult                      shift and go to state 23
    expr_unaire                    shift and go to state 25
    expr_primaire                  shift and go to state 26

state 35

    (13) instruction -> ECRIRE ( . CHAINE ) ;
    (14) instruction -> ECRIRE ( . expr ) ;
    (15) expr -> . expr_ou
    (16) expr_ou -> . expr_et
    (17) expr_ou -> . expr_ou OU expr_et
    (18) expr_et -> . expr_non
    (19) expr_et -> . expr_et ET expr_non
    (20) expr_non -> . expr_comp
    (21) expr_non -> . NON expr_non
    (22) expr_comp -> . expr_add
    (23) expr_comp -> . expr_comp SUPERIEUR_OU_EGAL expr_add
    (24) expr_comp -> . expr_comp INFERIEUR_OU_EGAL expr_add
    (25) expr_comp -> . expr_comp > expr_add
    (26) expr_comp -> . expr_comp < expr_add
    (27) expr_comp -> . expr_comp DIFFERENT expr_add
    (28) expr_comp -> . expr_comp EGAL_EGAL expr_add
    (29) expr_add -> . expr_mult
    (30) expr_add -> . expr_add - expr_mult
    (31) expr_add -> . expr_add + expr_mult
    (32) expr_mult -> . expr_unaire
    (33) expr_mult -> . expr_mult % expr_unaire
    (34) expr_mult -> . expr_mult / expr_unaire
    (35) expr_mult -> . expr_mult * expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    CHAINE          shift and go to state 64
    NON             shift and go to state 21
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr                           shift and go to state 65
    expr_ou                        shift and go to state 17
    expr_et                        shift and go to state 18
    expr_non                       shift and go to state 19
    expr_comp                      shift and go to state 20
    expr_add                       shift and go to state 22
    expr_mult                      shift and go to state 23
    expr_unaire                    shift and go to state 25
    expr_primaire                  shift and go to state 26

state 36

    (4) instruction -> type IDENTIFIANT ( . listeParamsOpt ) bloc
    (52) listeParamsOpt -> . listeParams
    (53) listeParamsOpt -> .
    (54) listeParams -> . listeParams , type IDENTIFIANT
    (55) listeParams -> . type IDENTIFIANT
    (45) type -> . BOOLEEN_TYPE
    (46) type -> . ENTIER_TYPE
    )               reduce using rule 53 (listeParamsOpt -> .)
    BOOLEEN_TYPE    shift and go to state 10
    ENTIER_TYPE     shift and go to state 11

    type                           shift and go to state 66
    listeParamsOpt                 shift and go to state 67
    listeParams                    shift and go to state 68

state 37

    (10) instruction -> type IDENTIFIANT = . expr ;
    (15) expr -> . expr_ou
    (16) expr_ou -> . expr_et
    (17) expr_ou -> . expr_ou OU expr_et
    (18) expr_et -> . expr_non
    (19) expr_et -> . expr_et ET expr_non
    (20) expr_non -> . expr_comp
    (21) expr_non -> . NON expr_non
    (22) expr_comp -> . expr_add
    (23) expr_comp -> . expr_comp SUPERIEUR_OU_EGAL expr_add
    (24) expr_comp -> . expr_comp INFERIEUR_OU_EGAL expr_add
    (25) expr_comp -> . expr_comp > expr_add
    (26) expr_comp -> . expr_comp < expr_add
    (27) expr_comp -> . expr_comp DIFFERENT expr_add
    (28) expr_comp -> . expr_comp EGAL_EGAL expr_add
    (29) expr_add -> . expr_mult
    (30) expr_add -> . expr_add - expr_mult
    (31) expr_add -> . expr_add + expr_mult
    (32) expr_mult -> . expr_unaire
    (33) expr_mult -> . expr_mult % expr_unaire
    (34) expr_mult -> . expr_mult / expr_unaire
    (35) expr_mult -> . expr_mult * expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    NON             shift and go to state 21
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr                           shift and go to state 69
    expr_ou                        shift and go to state 17
    expr_et                        shift and go to state 18
    expr_non                       shift and go to state 19
    expr_comp                      shift and go to state 20
    expr_add                       shift and go to state 22
    expr_mult                      shift and go to state 23
    expr_unaire                    shift and go to state 25
    expr_primaire                  shift and go to state 26

state 38

    (12) instruction -> type IDENTIFIANT ; .
    IDENTIFIANT     reduce using rule 12 (instruction -> type IDENTIFIANT ; .)
    RETOURNER       reduce using rule 12 (instruction -> type IDENTIFIANT ; .)
    TANTQUE         reduce using rule 12 (instruction -> type IDENTIFIANT ; .)
    SI              reduce using rule 12 (instruction -> type IDENTIFIANT ; .)
    ECRIRE          reduce using rule 12 (instruction -> type IDENTIFIANT ; .)
    BOOLEEN_TYPE    reduce using rule 12 (instruction -> type IDENTIFIANT ; .)
    ENTIER_TYPE     reduce using rule 12 (instruction -> type IDENTIFIANT ; .)
    $end            reduce using rule 12 (instruction -> type IDENTIFIANT ; .)
    }               reduce using rule 12 (instruction -> type IDENTIFIANT ; .)


state 39

    (5) instruction -> IDENTIFIANT ( listeArgsOpt . ) ;
    )               shift and go to state 70


state 40

    (50) listeArgsOpt -> listeArgs .
    (48) listeArgs -> listeArgs . , expr
    )               reduce using rule 50 (listeArgsOpt -> listeArgs .)
    ,               shift and go to state 71


state 41

    (49) listeArgs -> expr .
    ,               reduce using rule 49 (listeArgs -> expr .)
    )               reduce using rule 49 (listeArgs -> expr .)


state 42

    (11) instruction -> IDENTIFIANT = expr . ;
    ;               shift and go to state 72


state 43

    (6) instruction -> RETOURNER expr ; .
    IDENTIFIANT     reduce using rule 6 (instruction -> RETOURNER expr ; .)
    RETOURNER       reduce using rule 6 (instruction -> RETOURNER expr ; .)
    TANTQUE         reduce using rule 6 (instruction -> RETOURNER expr ; .)
    SI              reduce using rule 6 (instruction -> RETOURNER expr ; .)
    ECRIRE          reduce using rule 6 (instruction -> RETOURNER expr ; .)
    BOOLEEN_TYPE    reduce using rule 6 (instruction -> RETOURNER expr ; .)
    ENTIER_TYPE     reduce using rule 6 (instruction -> RETOURNER expr ; .)
    $end            reduce using rule 6 (instruction -> RETOURNER expr ; .)
    }               reduce using rule 6 (instruction -> RETOURNER expr ; .)


state 44

    (17) expr_ou -> expr_ou OU . expr_et
    (18) expr_et -> . expr_non
    (19) expr_et -> . expr_et ET expr_non
    (20) expr_non -> . expr_comp
    (21) expr_non -> . NON expr_non
    (22) expr_comp -> . expr_add
    (23) expr_comp -> . expr_comp SUPERIEUR_OU_EGAL expr_add
    (24) expr_comp -> . expr_comp INFERIEUR_OU_EGAL expr_add
    (25) expr_comp -> . expr_comp > expr_add
    (26) expr_comp -> . expr_comp < expr_add
    (27) expr_comp -> . expr_comp DIFFERENT expr_add
    (28) expr_comp -> . expr_comp EGAL_EGAL expr_add
    (29) expr_add -> . expr_mult
    (30) expr_add -> . expr_add - expr_mult
    (31) expr_add -> . expr_add + expr_mult
    (32) expr_mult -> . expr_unaire
    (33) expr_mult -> . expr_mult % expr_unaire
    (34) expr_mult -> . expr_mult / expr_unaire
    (35) expr_mult -> . expr_mult * expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    NON             shift and go to state 21
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr_et                        shift and go to state 73
    expr_non                       shift and go to state 19
    expr_comp                      shift and go to state 20
    expr_add                       shift and go to state 22
    expr_mult                      shift and go to state 23
    expr_unaire                    shift and go to state 25
    expr_primaire                  shift and go to state 26

state 45

    (19) expr_et -> expr_et ET . expr_non
    (20) expr_non -> . expr_comp
    (21) expr_non -> . NON expr_non
    (22) expr_comp -> . expr_add
    (23) expr_comp -> . expr_comp SUPERIEUR_OU_EGAL expr_add
    (24) expr_comp -> . expr_comp INFERIEUR_OU_EGAL expr_add
    (25) expr_comp -> . expr_comp > expr_add
    (26) expr_comp -> . expr_comp < expr_add
    (27) expr_comp -> . expr_comp DIFFERENT expr_add
    (28) expr_comp -> . expr_comp EGAL_EGAL expr_add
    (29) expr_add -> . expr_mult
    (30) expr_add -> . expr_add - expr_mult
    (31) expr_add -> . expr_add + expr_mult
    (32) expr_mult -> . expr_unaire
    (33) expr_mult -> . expr_mult % expr_unaire
    (34) expr_mult -> . expr_mult / expr_unaire
    (35) expr_mult -> . expr_mult * expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    NON             shift and go to state 21
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr_non                       shift and go to state 74
    expr_comp                      shift and go to state 20
    expr_add                       shift and go to state 22
    expr_mult                      shift and go to state 23
    expr_unaire                    shift and go to state 25
    expr_primaire                  shift and go to state 26

state 46

    (23) expr_comp -> expr_comp SUPERIEUR_OU_EGAL . expr_add
    (29) expr_add -> . expr_mult
    (30) expr_add -> . expr_add - expr_mult
    (31) expr_add -> . expr_add + expr_mult
    (32) expr_mult -> . expr_unaire
    (33) expr_mult -> . expr_mult % expr_unaire
    (34) expr_mult -> . expr_mult / expr_unaire
    (35) expr_mult -> . expr_mult * expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr_add                       shift and go to state 75
    expr_mult                      shift and go to state 23
    expr_unaire                    shift and go to state 25
    expr_primaire                  shift and go to state 26

state 47

    (24) expr_comp -> expr_comp INFERIEUR_OU_EGAL . expr_add
    (29) expr_add -> . expr_mult
    (30) expr_add -> . expr_add - expr_mult
    (31) expr_add -> . expr_add + expr_mult
    (32) expr_mult -> . expr_unaire
    (33) expr_mult -> . expr_mult % expr_unaire
    (34) expr_mult -> . expr_mult / expr_unaire
    (35) expr_mult -> . expr_mult * expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr_add                       shift and go to state 76
    expr_mult                      shift and go to state 23
    expr_unaire                    shift and go to state 25
    expr_primaire                  shift and go to state 26

state 48

    (25) expr_comp -> expr_comp > . expr_add
    (29) expr_add -> . expr_mult
    (30) expr_add -> . expr_add - expr_mult
    (31) expr_add -> . expr_add + expr_mult
    (32) expr_mult -> . expr_unaire
    (33) expr_mult -> . expr_mult % expr_unaire
    (34) expr_mult -> . expr_mult / expr_unaire
    (35) expr_mult -> . expr_mult * expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr_add                       shift and go to state 77
    expr_mult                      shift and go to state 23
    expr_unaire                    shift and go to state 25
    expr_primaire                  shift and go to state 26

state 49

    (26) expr_comp -> expr_comp < . expr_add
    (29) expr_add -> . expr_mult
    (30) expr_add -> . expr_add - expr_mult
    (31) expr_add -> . expr_add + expr_mult
    (32) expr_mult -> . expr_unaire
    (33) expr_mult -> . expr_mult % expr_unaire
    (34) expr_mult -> . expr_mult / expr_unaire
    (35) expr_mult -> . expr_mult * expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr_add                       shift and go to state 78
    expr_mult                      shift and go to state 23
    expr_unaire                    shift and go to state 25
    expr_primaire                  shift and go to state 26

state 50

    (27) expr_comp -> expr_comp DIFFERENT . expr_add
    (29) expr_add -> . expr_mult
    (30) expr_add -> . expr_add - expr_mult
    (31) expr_add -> . expr_add + expr_mult
    (32) expr_mult -> . expr_unaire
    (33) expr_mult -> . expr_mult % expr_unaire
    (34) expr_mult -> . expr_mult / expr_unaire
    (35) expr_mult -> . expr_mult * expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr_add                       shift and go to state 79
    expr_mult                      shift and go to state 23
    expr_unaire                    shift and go to state 25
    expr_primaire                  shift and go to state 26

state 51

    (28) expr_comp -> expr_comp EGAL_EGAL . expr_add
    (29) expr_add -> . expr_mult
    (30) expr_add -> . expr_add - expr_mult
    (31) expr_add -> . expr_add + expr_mult
    (32) expr_mult -> . expr_unaire
    (33) expr_mult -> . expr_mult % expr_unaire
    (34) expr_mult -> . expr_mult / expr_unaire
    (35) expr_mult -> . expr_mult * expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr_add                       shift and go to state 80
    expr_mult                      shift and go to state 23
    expr_unaire                    shift and go to state 25
    expr_primaire                  shift and go to state 26

state 52

    (21) expr_non -> NON expr_non .
    ET              reduce using rule 21 (expr_non -> NON expr_non .)
    OU              reduce using rule 21 (expr_non -> NON expr_non .)
    ;               reduce using rule 21 (expr_non -> NON expr_non .)
    ,               reduce using rule 21 (expr_non -> NON expr_non .)
    )               reduce using rule 21 (expr_non -> NON expr_non .)


state 53

    (30) expr_add -> expr_add - . expr_mult
    (32) expr_mult -> . expr_unaire
    (33) expr_mult -> . expr_mult % expr_unaire
    (34) expr_mult -> . expr_mult / expr_unaire
    (35) expr_mult -> . expr_mult * expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr_mult                      shift and go to state 81
    expr_unaire                    shift and go to state 25
    expr_primaire                  shift and go to state 26

state 54

    (31) expr_add -> expr_add + . expr_mult
    (32) expr_mult -> . expr_unaire
    (33) expr_mult -> . expr_mult % expr_unaire
    (34) expr_mult -> . expr_mult / expr_unaire
    (35) expr_mult -> . expr_mult * expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr_mult                      shift and go to state 82
    expr_unaire                    shift and go to state 25
    expr_primaire                  shift and go to state 26

state 55

    (33) expr_mult -> expr_mult % . expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr_unaire                    shift and go to state 83
    expr_primaire                  shift and go to state 26

state 56

    (34) expr_mult -> expr_mult / . expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr_unaire                    shift and go to state 84
    expr_primaire                  shift and go to state 26

state 57

    (35) expr_mult -> expr_mult * . expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr_unaire                    shift and go to state 85
    expr_primaire                  shift and go to state 26

state 58

    (37) expr_unaire -> - expr_unaire .
    %               reduce using rule 37 (expr_unaire -> - expr_unaire .)
    /               reduce using rule 37 (expr_unaire -> - expr_unaire .)
    *               reduce using rule 37 (expr_unaire -> - expr_unaire .)
    -               reduce using rule 37 (expr_unaire -> - expr_unaire .)
    +               reduce using rule 37 (expr_unaire -> - expr_unaire .)
    SUPERIEUR_OU_EGAL reduce using rule 37 (expr_unaire -> - expr_unaire .)
    INFERIEUR_OU_EGAL reduce using rule 37 (expr_unaire -> - expr_unaire .)
    >               reduce using rule 37 (expr_unaire -> - expr_unaire .)
    <               reduce using rule 37 (expr_unaire -> - expr_unaire .)
    DIFFERENT       reduce using rule 37 (expr_unaire -> - expr_unaire .)
    EGAL_EGAL       reduce using rule 37 (expr_unaire -> - expr_unaire .)
    ET              reduce using rule 37 (expr_unaire -> - expr_unaire .)
    OU              reduce using rule 37 (expr_unaire -> - expr_unaire .)
    ;               reduce using rule 37 (expr_unaire -> - expr_unaire .)
    ,               reduce using rule 37 (expr_unaire -> - expr_unaire .)
    )               reduce using rule 37 (expr_unaire -> - expr_unaire .)


state 59

    (38) expr_primaire -> IDENTIFIANT ( . listeArgsOpt )
    (50) listeArgsOpt -> . listeArgs
    (51) listeArgsOpt -> .
    (48) listeArgs -> . listeArgs , expr
    (49) listeArgs -> . expr
    (15) expr -> . expr_ou
    (16) expr_ou -> . expr_et
    (17) expr_ou -> . expr_ou OU expr_et
    (18) expr_et -> . expr_non
    (19) expr_et -> . expr_et ET expr_non
    (20) expr_non -> . expr_comp
    (21) expr_non -> . NON expr_non
    (22) expr_comp -> . expr_add
    (23) expr_comp -> . expr_comp SUPERIEUR_OU_EGAL expr_add
    (24) expr_comp -> . expr_comp INFERIEUR_OU_EGAL expr_add
    (25) expr_comp -> . expr_comp > expr_add
    (26) expr_comp -> . expr_comp < expr_add
    (27) expr_comp -> . expr_comp DIFFERENT expr_add
    (28) expr_comp -> . expr_comp EGAL_EGAL expr_add
    (29) expr_add -> . expr_mult
    (30) expr_add -> . expr_add - expr_mult
    (31) expr_add -> . expr_add + expr_mult
    (32) expr_mult -> . expr_unaire
    (33) expr_mult -> . expr_mult % expr_unaire
    (34) expr_mult -> . expr_mult / expr_unaire
    (35) expr_mult -> . expr_mult * expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    )               reduce using rule 51 (listeArgsOpt -> .)
    NON             shift and go to state 21
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    listeArgsOpt                   shift and go to state 86
    listeArgs                      shift and go to state 40
    expr                           shift and go to state 41
    expr_ou                        shift and go to state 17
    expr_et                        shift and go to state 18
    expr_non                       shift and go to state 19
    expr_comp                      shift and go to state 20
    expr_add                       shift and go to state 22
    expr_mult                      shift and go to state 23
    expr_unaire                    shift and go to state 25
    expr_primaire                  shift and go to state 26

state 60

    (44) expr_primaire -> ( expr . )
    )               shift and go to state 87


state 61

    (39) expr_primaire -> LIRE ( . )
    )               shift and go to state 88


state 62

    (7) instruction -> TANTQUE ( expr . ) bloc
    )               shift and go to state 89


state 63

    (8) instruction -> SI ( expr . ) bloc SINON bloc
    (9) instruction -> SI ( expr . ) bloc
    )               shift and go to state 90


state 64

    (13) instruction -> ECRIRE ( CHAINE . ) ;
    )               shift and go to state 91


state 65

    (14) instruction -> ECRIRE ( expr . ) ;
    )               shift and go to state 92


state 66

    (55) listeParams -> type . IDENTIFIANT
    IDENTIFIANT     shift and go to state 93


state 67

    (4) instruction -> type IDENTIFIANT ( listeParamsOpt . ) bloc
    )               shift and go to state 94


state 68

    (52) listeParamsOpt -> listeParams .
    (54) listeParams -> listeParams . , type IDENTIFIANT
    )               reduce using rule 52 (listeParamsOpt -> listeParams .)
    ,               shift and go to state 95


state 69

    (10) instruction -> type IDENTIFIANT = expr . ;
    ;               shift and go to state 96


state 70

    (5) instruction -> IDENTIFIANT ( listeArgsOpt ) . ;
    ;               shift and go to state 97


state 71

    (48) listeArgs -> listeArgs , . expr
    (15) expr -> . expr_ou
    (16) expr_ou -> . expr_et
    (17) expr_ou -> . expr_ou OU expr_et
    (18) expr_et -> . expr_non
    (19) expr_et -> . expr_et ET expr_non
    (20) expr_non -> . expr_comp
    (21) expr_non -> . NON expr_non
    (22) expr_comp -> . expr_add
    (23) expr_comp -> . expr_comp SUPERIEUR_OU_EGAL expr_add
    (24) expr_comp -> . expr_comp INFERIEUR_OU_EGAL expr_add
    (25) expr_comp -> . expr_comp > expr_add
    (26) expr_comp -> . expr_comp < expr_add
    (27) expr_comp -> . expr_comp DIFFERENT expr_add
    (28) expr_comp -> . expr_comp EGAL_EGAL expr_add
    (29) expr_add -> . expr_mult
    (30) expr_add -> . expr_add - expr_mult
    (31) expr_add -> . expr_add + expr_mult
    (32) expr_mult -> . expr_unaire
    (33) expr_mult -> . expr_mult % expr_unaire
    (34) expr_mult -> . expr_mult / expr_unaire
    (35) expr_mult -> . expr_mult * expr_unaire
    (36) expr_unaire -> . expr_primaire
    (37) expr_unaire -> . - expr_unaire
    (38) expr_primaire -> . IDENTIFIANT ( listeArgsOpt )
    (39) expr_primaire -> . LIRE ( )
    (40) expr_primaire -> . IDENTIFIANT
    (41) expr_primaire -> . FAUX
    (42) expr_primaire -> . VRAI
    (43) expr_primaire -> . ENTIER
    (44) expr_primaire -> . ( expr )
    NON             shift and go to state 21
    -               shift and go to state 24
    IDENTIFIANT     shift and go to state 27
    LIRE            shift and go to state 29
    FAUX            shift and go to state 30
    VRAI            shift and go to state 31
    ENTIER          shift and go to state 32
    (               shift and go to state 28

    expr                           shift and go to state 98
    expr_ou                        shift and go to state 17
    expr_et                        shift and go to state 18
    expr_non                       shift and go to state 19
    expr_comp                      shift and go to state 20
    expr_add                       shift and go to state 22
    expr_mult                      shift and go to state 23
    expr_unaire                    shift and go to state 25
    expr_primaire                  shift and go to state 26

state 72

    (11) instruction -> IDENTIFIANT = expr ; .
    IDENTIFIANT     reduce using rule 11 (instruction -> IDENTIFIANT = expr ; .)
    RETOURNER       reduce using rule 11 (instruction -> IDENTIFIANT = expr ; .)
    TANTQUE         reduce using rule 11 (instruction -> IDENTIFIANT = expr ; .)
    SI              reduce using rule 11 (instruction -> IDENTIFIANT = expr ; .)
    ECRIRE          reduce using rule 11 (instruction -> IDENTIFIANT = expr ; .)
    BOOLEEN_TYPE    reduce using rule 11 (instruction -> IDENTIFIANT = expr ; .)
    ENTIER_TYPE     reduce using rule 11 (instruction -> IDENTIFIANT = expr ; .)
    $end            reduce using rule 11 (instruction -> IDENTIFIANT = expr ; .)
    }               reduce using rule 11 (instruction -> IDENTIFIANT = expr ; .)


state 73

    (17) expr_ou -> expr_ou OU expr_et .
    (19) expr_et -> expr_et . ET expr_non
    OU              reduce using rule 17 (expr_ou -> expr_ou OU expr_et .)
    ;               reduce using rule 17 (expr_ou -> expr_ou OU expr_et .)
    ,               reduce using rule 17 (expr_ou -> expr_ou OU expr_et .)
    )               reduce using rule 17 (expr_ou -> expr_ou OU expr_et .)
    ET              shift and go to state 45


state 74

    (19) expr_et -> expr_et ET expr_non .
    ET              reduce using rule 19 (expr_et -> expr_et ET expr_non .)
    OU              reduce using rule 19 (expr_et -> expr_et ET expr_non .)
    ;               reduce using rule 19 (expr_et -> expr_et ET expr_non .)
    ,               reduce using rule 19 (expr_et -> expr_et ET expr_non .)
    )               reduce using rule 19 (expr_et -> expr_et ET expr_non .)


state 75

    (23) expr_comp -> expr_comp SUPERIEUR_OU_EGAL expr_add .
    (30) expr_add -> expr_add . - expr_mult
    (31) expr_add -> expr_add . + expr_mult
    SUPERIEUR_OU_EGAL reduce using rule 23 (expr_comp -> expr_comp SUPERIEUR_OU_EGAL expr_add .)
    INFERIEUR_OU_EGAL reduce using rule 23 (expr_comp -> expr_comp SUPERIEUR_OU_EGAL expr_add .)
    >               reduce using rule 23 (expr_comp -> expr_comp SUPERIEUR_OU_EGAL expr_add .)
    <               reduce using rule 23 (expr_comp -> expr_comp SUPERIEUR_OU_EGAL expr_add .)
    DIFFERENT       reduce using rule 23 (expr_comp -> expr_comp SUPERIEUR_OU_EGAL expr_add .)
    EGAL_EGAL       reduce using rule 23 (expr_comp -> expr_comp SUPERIEUR_OU_EGAL expr_add .)
    ET              reduce using rule 23 (expr_comp -> expr_comp SUPERIEUR_OU_EGAL expr_add .)
    OU              reduce using rule 23 (expr_comp -> expr_comp SUPERIEUR_OU_EGAL expr_add .)
    ;               reduce using rule 23 (expr_comp -> expr_comp SUPERIEUR_OU_EGAL expr_add .)
    ,               reduce using rule 23 (expr_comp -> expr_comp SUPERIEUR_OU_EGAL expr_add .)
    )               reduce using rule 23 (expr_comp -> expr_comp SUPERIEUR_OU_EGAL expr_add .)
    -               shift and go to state 53
    +               shift and go to state 54


state 76

    (24) expr_comp -> expr_comp INFERIEUR_OU_EGAL expr_add .
    (30) expr_add -> expr_add . - expr_mult
    (31) expr_add -> expr_add . + expr_mult
    SUPERIEUR_OU_EGAL reduce using rule 24 (expr_comp -> expr_comp INFERIEUR_OU_EGAL expr_add .)
    INFERIEUR_OU_EGAL reduce using rule 24 (expr_comp -> expr_comp INFERIEUR_OU_EGAL expr_add .)
    >               reduce using rule 24 (expr_comp -> expr_comp INFERIEUR_OU_EGAL expr_add .)
    <               reduce using rule 24 (expr_comp -> expr_comp INFERIEUR_OU_EGAL expr_add .)
    DIFFERENT       reduce using rule 24 (expr_comp -> expr_comp INFERIEUR_OU_EGAL expr_add .)
    EGAL_EGAL       reduce using rule 24 (expr_comp -> expr_comp INFERIEUR_OU_EGAL expr_add .)
    ET              reduce using rule 24 (expr_comp -> expr_comp INFERIEUR_OU_EGAL expr_add .)
    OU              reduce using rule 24 (expr_comp -> expr_comp INFERIEUR_OU_EGAL expr_add .)
    ;               reduce using rule 24 (expr_comp -> expr_comp INFERIEUR_OU_EGAL expr_add .)
    ,               reduce using rule 24 (expr_comp -> expr_comp INFERIEUR_OU_EGAL expr_add .)
    )               reduce using rule 24 (expr_comp -> expr_comp INFERIEUR_OU_EGAL expr_add .)
    -               shift and go to state 53
    +               shift and go to state 54


state 77

    (25) expr_comp -> expr_comp > expr_add .
    (30) expr_add -> expr_add . - expr_mult
    (31) expr_add -> expr_add . + expr_mult
    SUPERIEUR_OU_EGAL reduce using rule 25 (expr_comp -> expr_comp > expr_add .)
    INFERIEUR_OU_EGAL reduce using rule 25 (expr_comp -> expr_comp > expr_add .)
    >               reduce using rule 25 (expr_comp -> expr_comp > expr_add .)
    <               reduce using rule 25 (expr_comp -> expr_comp > expr_add .)
    DIFFERENT       reduce using rule 25 (expr_comp -> expr_comp > expr_add .)
    EGAL_EGAL       reduce using rule 25 (expr_comp -> expr_comp > expr_add .)
    ET              reduce using rule 25 (expr_comp -> expr_comp > expr_add .)
    OU              reduce using rule 25 (expr_comp -> expr_comp > expr_add .)
    ;               reduce using rule 25 (expr_comp -> expr_comp > expr_add .)
    ,               reduce using rule 25 (expr_comp -> expr_comp > expr_add .)
    )               reduce using rule 25 (expr_comp -> expr_comp > expr_add .)
    -               shift and go to state 53
    +               shift and go to state 54


state 78

    (26) expr_comp -> expr_comp < expr_add .
    (30) expr_add -> expr_add . - expr_mult
    (31) expr_add -> expr_add . + expr_mult
    SUPERIEUR_OU_EGAL reduce using rule 26 (expr_comp -> expr_comp < expr_add .)
    INFERIEUR_OU_EGAL reduce using rule 26 (expr_comp -> expr_comp < expr_add .)
    >               reduce using rule 26 (expr_comp -> expr_comp < expr_add .)
    <               reduce using rule 26 (expr_comp -> expr_comp < expr_add .)
    DIFFERENT       reduce using rule 26 (expr_comp -> expr_comp < expr_add .)
    EGAL_EGAL       reduce using rule 26 (expr_comp -> expr_comp < expr_add .)
    ET              reduce using rule 26 (expr_comp -> expr_comp < expr_add .)
    OU              reduce using rule 26 (expr_comp -> expr_comp < expr_add .)
    ;               reduce using rule 26 (expr_comp -> expr_comp < expr_add .)
    ,               reduce using rule 26 (expr_comp -> expr_comp < expr_add .)
    )               reduce using rule 26 (expr_comp -> expr_comp < expr_add .)
    -               shift and go to state 53
    +               shift and go to state 54


state 79

    (27) expr_comp -> expr_comp DIFFERENT expr_add .
    (30) expr_add -> expr_add . - expr_mult
    (31) expr_add -> expr_add . + expr_mult
    SUPERIEUR_OU_EGAL reduce using rule 27 (expr_comp -> expr_comp DIFFERENT expr_add .)
    INFERIEUR_OU_EGAL reduce using rule 27 (expr_comp -> expr_comp DIFFERENT expr_add .)
    >               reduce using rule 27 (expr_comp -> expr_comp DIFFERENT expr_add .)
    <               reduce using rule 27 (expr_comp -> expr_comp DIFFERENT expr_add .)
    DIFFERENT       reduce using rule 27 (expr_comp -> expr_comp DIFFERENT expr_add .)
    EGAL_EGAL       reduce using rule 27 (expr_comp -> expr_comp DIFFERENT expr_add .)
    ET              reduce using rule 27 (expr_comp -> expr_comp DIFFERENT expr_add .)
    OU              reduce using rule 27 (expr_comp -> expr_comp DIFFERENT expr_add .)
    ;               reduce using rule 27 (expr_comp -> expr_comp DIFFERENT expr_add .)
    ,               reduce using rule 27 (expr_comp -> expr_comp DIFFERENT expr_add .)
    )               reduce using rule 27 (expr_comp -> expr_comp DIFFERENT expr_add .)
    -               shift and go to state 53
    +               shift and go to state 54


state 80

    (28) expr_comp -> expr_comp EGAL_EGAL expr_add .
    (30) expr_add -> expr_add . - expr_mult
    (31) expr_add -> expr_add . + expr_mult
    SUPERIEUR_OU_EGAL reduce using rule 28 (expr_comp -> expr_comp EGAL_EGAL expr_add .)
    INFERIEUR_OU_EGAL reduce using rule 28 (expr_comp -> expr_comp EGAL_EGAL expr_add .)
    >               reduce using rule 28 (expr_comp -> expr_comp EGAL_EGAL expr_add .)
    <               reduce using rule 28 (expr_comp -> expr_comp EGAL_EGAL expr_add .)
    DIFFERENT       reduce using rule 28 (expr_comp -> expr_comp EGAL_EGAL expr_add .)
    EGAL_EGAL       reduce using rule 28 (expr_comp -> expr_comp EGAL_EGAL expr_add .)
    ET              reduce using rule 28 (expr_comp -> expr_comp EGAL_EGAL expr_add .)
    OU              reduce using rule 28 (expr_comp -> expr_comp EGAL_EGAL expr_add .)
    ;               reduce using rule 28 (expr_comp -> expr_comp EGAL_EGAL expr_add .)
    ,               reduce using rule 28 (expr_comp -> expr_comp EGAL_EGAL expr_add .)
    )               reduce using rule 28 (expr_comp -> expr_comp EGAL_EGAL expr_add .)
    -               shift and go to state 53
    +               shift and go to state 54


state 81

    (30) expr_add -> expr_add - expr_mult .
    (33) expr_mult -> expr_mult . % expr_unaire
    (34) expr_mult -> expr_mult . / expr_unaire
    (35) expr_mult -> expr_mult . * expr_unaire
    -               reduce using rule 30 (expr_add -> expr_add - expr_mult .)
    +               reduce using rule 30 (expr_add -> expr_add - expr_mult .)
    SUPERIEUR_OU_EGAL reduce using rule 30 (expr_add -> expr_add - expr_mult .)
    INFERIEUR_OU_EGAL reduce using rule 30 (expr_add -> expr_add - expr_mult .)
    >               reduce using rule 30 (expr_add -> expr_add - expr_mult .)
    <               reduce using rule 30 (expr_add -> expr_add - expr_mult .)
    DIFFERENT       reduce using rule 30 (expr_add -> expr_add - expr_mult .)
    EGAL_EGAL       reduce using rule 30 (expr_add -> expr_add - expr_mult .)
    ET              reduce using rule 30 (expr_add -> expr_add - expr_mult .)
    OU              reduce using rule 30 (expr_add -> expr_add - expr_mult .)
    ;               reduce using rule 30 (expr_add -> expr_add - expr_mult .)
    ,               reduce using rule 30 (expr_add -> expr_add - expr_mult .)
    )               reduce using rule 30 (expr_add -> expr_add - expr_mult .)
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57


state 82

    (31) expr_add -> expr_add + expr_mult .
    (33) expr_mult -> expr_mult . % expr_unaire
    (34) expr_mult -> expr_mult . / expr_unaire
    (35) expr_mult -> expr_mult . * expr_unaire
    -               reduce using rule 31 (expr_add -> expr_add + expr_mult .)
    +               reduce using rule 31 (expr_add -> expr_add + expr_mult .)
    SUPERIEUR_OU_EGAL reduce using rule 31 (expr_add -> expr_add + expr_mult .)
    INFERIEUR_OU_EGAL reduce using rule 31 (expr_add -> expr_add + expr_mult .)
    >               reduce using rule 31 (expr_add -> expr_add + expr_mult .)
    <               reduce using rule 31 (expr_add -> expr_add + expr_mult .)
    DIFFERENT       reduce using rule 31 (expr_add -> expr_add + expr_mult .)
    EGAL_EGAL       reduce using rule 31 (expr_add -> expr_add + expr_mult .)
    ET              reduce using rule 31 (expr_add -> expr_add + expr_mult .)
    OU              reduce using rule 31 (expr_add -> expr_add + expr_mult .)
    ;               reduce using rule 31 (expr_add -> expr_add + expr_mult .)
    ,               reduce using rule 31 (expr_add -> expr_add + expr_mult .)
    )               reduce using rule 31 (expr_add -> expr_add + expr_mult .)
    %               shift and go to state 55
    /               shift and go to state 56
    *               shift and go to state 57


state 83

    (33) expr_mult -> expr_mult % expr_unaire .
    %               reduce using rule 33 (expr_mult -> expr_mult % expr_unaire .)
    /               reduce using rule 33 (expr_mult -> expr_mult % expr_unaire .)
    *               reduce using rule 33 (expr_mult -> expr_mult % expr_unaire .)
    -               reduce using rule 33 (expr_mult -> expr_mult % expr_unaire .)
    +               reduce using rule 33 (expr_mult -> expr_mult % expr_unaire .)
    SUPERIEUR_OU_EGAL reduce using rule 33 (expr_mult -> expr_mult % expr_unaire .)
    INFERIEUR_OU_EGAL reduce using rule 33 (expr_mult -> expr_mult % expr_unaire .)
    >               reduce using rule 33 (expr_mult -> expr_mult % expr_unaire .)
    <               reduce using rule 33 (expr_mult -> expr_mult % expr_unaire .)
    DIFFERENT       reduce using rule 33 (expr_mult -> expr_mult % expr_unaire .)
    EGAL_EGAL       reduce using rule 33 (expr_mult -> expr_mult % expr_unaire .)
    ET              reduce using rule 33 (expr_mult -> expr_mult % expr_unaire .)
    OU              reduce using rule 33 (expr_mult -> expr_mult % expr_unaire .)
    ;               reduce using rule 33 (expr_mult -> expr_mult % expr_unaire .)
    ,               reduce using rule 33 (expr_mult -> expr_mult % expr_unaire .)
    )               reduce using rule 33 (expr_mult -> expr_mult % expr_unaire .)


state 84

    (34) expr_mult -> expr_mult / expr_unaire .
    %               reduce using rule 34 (expr_mult -> expr_mult / expr_unaire .)
    /               reduce using rule 34 (expr_mult -> expr_mult / expr_unaire .)
    *               reduce using rule 34 (expr_mult -> expr_mult / expr_unaire .)
    -               reduce using rule 34 (expr_mult -> expr_mult / expr_unaire .)
    +               reduce using rule 34 (expr_mult -> expr_mult / expr_unaire .)
    SUPERIEUR_OU_EGAL reduce using rule 34 (expr_mult -> expr_mult / expr_unaire .)
    INFERIEUR_OU_EGAL reduce using rule 34 (expr_mult -> expr_mult / expr_unaire .)
    >               reduce using rule 34 (expr_mult -> expr_mult / expr_unaire .)
    <               reduce using rule 34 (expr_mult -> expr_mult / expr_unaire .)
    DIFFERENT       reduce using rule 34 (expr_mult -> expr_mult / expr_unaire .)
    EGAL_EGAL       reduce using rule 34 (expr_mult -> expr_mult / expr_unaire .)
    ET              reduce using rule 34 (expr_mult -> expr_mult / expr_unaire .)
    OU              reduce using rule 34 (expr_mult -> expr_mult / expr_unaire .)
    ;               reduce using rule 34 (expr_mult -> expr_mult / expr_unaire .)
    ,               reduce using rule 34 (expr_mult -> expr_mult / expr_unaire .)
    )               reduce using rule 34 (expr_mult -> expr_mult / expr_unaire .)


state 85

    (35) expr_mult -> expr_mult * expr_unaire .
    %               reduce using rule 35 (expr_mult -> expr_mult * expr_unaire .)
    /               reduce using rule 35 (expr_mult -> expr_mult * expr_unaire .)
    *               reduce using rule 35 (expr_mult -> expr_mult * expr_unaire .)
    -               reduce using rule 35 (expr_mult -> expr_mult * expr_unaire .)
    +               reduce using rule 35 (expr_mult -> expr_mult * expr_unaire .)
    SUPERIEUR_OU_EGAL reduce using rule 35 (expr_mult -> expr_mult * expr_unaire .)
    INFERIEUR_OU_EGAL reduce using rule 35 (expr_mult -> expr_mult * expr_unaire .)
    >               reduce using rule 35 (expr_mult -> expr_mult * expr_unaire .)
    <               reduce using rule 35 (expr_mult -> expr_mult * expr_unaire .)
    DIFFERENT       reduce using rule 35 (expr_mult -> expr_mult * expr_unaire .)
    EGAL_EGAL       reduce using rule 35 (expr_mult -> expr_mult * expr_unaire .)
    ET              reduce using rule 35 (expr_mult -> expr_mult * expr_unaire .)
    OU              reduce using rule 35 (expr_mult -> expr_mult * expr_unaire .)
    ;               reduce using rule 35 (expr_mult -> expr_mult * expr_unaire .)
    ,               reduce using rule 35 (expr_mult -> expr_mult * expr_unaire .)
    )               reduce using rule 35 (expr_mult -> expr_mult * expr_unaire .)


state 86

    (38) expr_primaire -> IDENTIFIANT ( listeArgsOpt . )
    )               shift and go to state 99


state 87

    (44) expr_primaire -> ( expr ) .
    %               reduce using rule 44 (expr_primaire -> ( expr ) .)
    /               reduce using rule 44 (expr_primaire -> ( expr ) .)
    *               reduce using rule 44 (expr_primaire -> ( expr ) .)
    -               reduce using rule 44 (expr_primaire -> ( expr ) .)
    +               reduce using rule 44 (expr_primaire -> ( expr ) .)
    SUPERIEUR_OU_EGAL reduce using rule 44 (expr_primaire -> ( expr ) .)
    INFERIEUR_OU_EGAL reduce using rule 44 (expr_primaire -> ( expr ) .)
    >               reduce using rule 44 (expr_primaire -> ( expr ) .)
    <               reduce using rule 44 (expr_primaire -> ( expr ) .)
    DIFFERENT       reduce using rule 44 (expr_primaire -> ( expr ) .)
    EGAL_EGAL       reduce using rule 44 (expr_primaire -> ( expr ) .)
    ET              reduce using rule 44 (expr_primaire -> ( expr ) .)
    OU              reduce using rule 44 (expr_primaire -> ( expr ) .)
    ;               reduce using rule 44 (expr_primaire -> ( expr ) .)
    ,               reduce using rule 44 (expr_primaire -> ( expr ) .)
    )               reduce using rule 44 (expr_primaire -> ( expr ) .)


state 88

    (39) expr_primaire -> LIRE ( ) .
    %               reduce using rule 39 (expr_primaire -> LIRE ( ) .)
    /               reduce using rule 39 (expr_primaire -> LIRE ( ) .)
    *               reduce using rule 39 (expr_primaire -> LIRE ( ) .)
    -               reduce using rule 39 (expr_primaire -> LIRE ( ) .)
    +               reduce using rule 39 (expr_primaire -> LIRE ( ) .)
    SUPERIEUR_OU_EGAL reduce using rule 39 (expr_primaire -> LIRE ( ) .)
    INFERIEUR_OU_EGAL reduce using rule 39 (expr_primaire -> LIRE ( ) .)
    >               reduce using rule 39 (expr_primaire -> LIRE ( ) .)
    <               reduce using rule 39 (expr_primaire -> LIRE ( ) .)
    DIFFERENT       reduce using rule 39 (expr_primaire -> LIRE ( ) .)
    EGAL_EGAL       reduce using rule 39 (expr_primaire -> LIRE ( ) .)
    ET              reduce using rule 39 (expr_primaire -> LIRE ( ) .)
    OU              reduce using rule 39 (expr_primaire -> LIRE ( ) .)
    ;               reduce using rule 39 (expr_primaire -> LIRE ( ) .)
    ,               reduce using rule 39 (expr_primaire -> LIRE ( ) .)
    )               reduce using rule 39 (expr_primaire -> LIRE ( ) .)


state 89

    (7) instruction -> TANTQUE ( expr ) . bloc
    (47) bloc -> . { listeInstructions }
    {               shift and go to state 101

    bloc                           shift and go to state 100

state 90

    (8) instruction -> SI ( expr ) . bloc SINON bloc
    (9) instruction -> SI ( expr ) . bloc
    (47) bloc -> . { listeInstructions }
    {               shift and go to state 101

    bloc                           shift and go to state 102

state 91

    (13) instruction -> ECRIRE ( CHAINE ) . ;
    ;               shift and go to state 103


state 92

    (14) instruction -> ECRIRE ( expr ) . ;
    ;               shift and go to state 104


state 93

    (55) listeParams -> type IDENTIFIANT .
    ,               reduce using rule 55 (listeParams -> type IDENTIFIANT .)
    )               reduce using rule 55 (listeParams -> type IDENTIFIANT .)


state 94

    (4) instruction -> type IDENTIFIANT ( listeParamsOpt ) . bloc
    (47) bloc -> . { listeInstructions }
    {               shift and go to state 101

    bloc                           shift and go to state 105

state 95

    (54) listeParams -> listeParams , . type IDENTIFIANT
    (45) type -> . BOOLEEN_TYPE
    (46) type -> . ENTIER_TYPE
    BOOLEEN_TYPE    shift and go to state 10
    ENTIER_TYPE     shift and go to state 11

    type                           shift and go to state 106

state 96

    (10) instruction -> type IDENTIFIANT = expr ; .
    IDENTIFIANT     reduce using rule 10 (instruction -> type IDENTIFIANT = expr ; .)
    RETOURNER       reduce using rule 10 (instruction -> type IDENTIFIANT = expr ; .)
    TANTQUE         reduce using rule 10 (instruction -> type IDENTIFIANT = expr ; .)
    SI              reduce using rule 10 (instruction -> type IDENTIFIANT = expr ; .)
    ECRIRE          reduce using rule 10 (instruction -> type IDENTIFIANT = expr ; .)
    BOOLEEN_TYPE    reduce using rule 10 (instruction -> type IDENTIFIANT = expr ; .)
    ENTIER_TYPE     reduce using rule 10 (instruction -> type IDENTIFIANT = expr ; .)
    $end            reduce using rule 10 (instruction -> type IDENTIFIANT = expr ; .)
    }               reduce using rule 10 (instruction -> type IDENTIFIANT = expr ; .)


state 97

    (5) instruction -> IDENTIFIANT ( listeArgsOpt ) ; .
    IDENTIFIANT     reduce using rule 5 (instruction -> IDENTIFIANT ( listeArgsOpt ) ; .)
    RETOURNER       reduce using rule 5 (instruction -> IDENTIFIANT ( listeArgsOpt ) ; .)
    TANTQUE         reduce using rule 5 (instruction -> IDENTIFIANT ( listeArgsOpt ) ; .)
    SI              reduce using rule 5 (instruction -> IDENTIFIANT ( listeArgsOpt ) ; .)
    ECRIRE          reduce using rule 5 (instruction -> IDENTIFIANT ( listeArgsOpt ) ; .)
    BOOLEEN_TYPE    reduce using rule 5 (instruction -> IDENTIFIANT ( listeArgsOpt ) ; .)
    ENTIER_TYPE     reduce using rule 5 (instruction -> IDENTIFIANT ( listeArgsOpt ) ; .)
    $end            reduce using rule 5 (instruction -> IDENTIFIANT ( listeArgsOpt ) ; .)
    }               reduce using rule 5 (instruction -> IDENTIFIANT ( listeArgsOpt ) ; .)


state 98

    (48) listeArgs -> listeArgs , expr .
    ,               reduce using rule 48 (listeArgs -> listeArgs , expr .)
    )               reduce using rule 48 (listeArgs -> listeArgs , expr .)


state 99

    (38) expr_primaire -> IDENTIFIANT ( listeArgsOpt ) .
    %               reduce using rule 38 (expr_primaire -> IDENTIFIANT ( listeArgsOpt ) .)
    /               reduce using rule 38 (expr_primaire -> IDENTIFIANT ( listeArgsOpt ) .)
    *               reduce using rule 38 (expr_primaire -> IDENTIFIANT ( listeArgsOpt ) .)
    -               reduce using rule 38 (expr_primaire -> IDENTIFIANT ( listeArgsOpt ) .)
    +               reduce using rule 38 (expr_primaire -> IDENTIFIANT ( listeArgsOpt ) .)
    SUPERIEUR_OU_EGAL reduce using rule 38 (expr_primaire -> IDENTIFIANT ( listeArgsOpt ) .)
    INFERIEUR_OU_EGAL reduce using rule 38 (expr_primaire -> IDENTIFIANT ( listeArgsOpt ) .)
    >               reduce using rule 38 (expr_primaire -> IDENTIFIANT ( listeArgsOpt ) .)
    <               reduce using rule 38 (expr_primaire -> IDENTIFIANT ( listeArgsOpt ) .)
    DIFFERENT       reduce using rule 38 (expr_primaire -> IDENTIFIANT ( listeArgsOpt ) .)
    EGAL_EGAL       reduce using rule 38 (expr_primaire -> IDENTIFIANT ( listeArgsOpt ) .)
    ET              reduce using rule 38 (expr_primaire -> IDENTIFIANT ( listeArgsOpt ) .)
    OU              reduce using rule 38 (expr_primaire -> IDENTIFIANT ( listeArgsOpt ) .)
    ;               reduce using rule 38 (expr_primaire -> IDENTIFIANT ( listeArgsOpt ) .)
    ,               reduce using rule 38 (expr_primaire -> IDENTIFIANT ( listeArgsOpt ) .)
    )               reduce using rule 38 (expr_primaire -> IDENTIFIANT ( listeArgsOpt ) .)


state 100

    (7) instruction -> TANTQUE ( expr ) bloc .
    IDENTIFIANT     reduce using rule 7 (instruction -> TANTQUE ( expr ) bloc .)
    RETOURNER       reduce using rule 7 (instruction -> TANTQUE ( expr ) bloc .)
    TANTQUE         reduce using rule 7 (instruction -> TANTQUE ( expr ) bloc .)
    SI              reduce using rule 7 (instruction -> TANTQUE ( expr ) bloc .)
    ECRIRE          reduce using rule 7 (instruction -> TANTQUE ( expr ) bloc .)
    BOOLEEN_TYPE    reduce using rule 7 (instruction -> TANTQUE ( expr ) bloc .)
    ENTIER_TYPE     reduce using rule 7 (instruction -> TANTQUE ( expr ) bloc .)
    $end            reduce using rule 7 (instruction -> TANTQUE ( expr ) bloc .)
    }               reduce using rule 7 (instruction -> TANTQUE ( expr ) bloc .)


state 101

    (47) bloc -> { . listeInstructions }
    (2) listeInstructions -> . instruction listeInstructions
    (3) listeInstructions -> . instruction
    (4) instruction -> . type IDENTIFIANT ( listeParamsOpt ) bloc
    (5) instruction -> . IDENTIFIANT ( listeArgsOpt ) ;
    (6) instruction -> . RETOURNER expr ;
    (7) instruction -> . TANTQUE ( expr ) bloc
    (8) instruction -> . SI ( expr ) bloc SINON bloc
    (9) instruction -> . SI ( expr ) bloc
    (10) instruction -> . type IDENTIFIANT = expr ;
    (11) instruction -> . IDENTIFIANT = expr ;
    (12) instruction -> . type IDENTIFIANT ;
    (13) instruction -> . ECRIRE ( CHAINE ) ;
    (14) instruction -> . ECRIRE ( expr ) ;
    (45) type -> . BOOLEEN_TYPE
    (46) type -> . ENTIER_TYPE
    IDENTIFIANT     shift and go to state 5
    RETOURNER       shift and go to state 6
    TANTQUE         shift and go to state 7
    SI              shift and go to state 8
    ECRIRE          shift and go to state 9
    BOOLEEN_TYPE    shift and go to state 10
    ENTIER_TYPE     shift and go to state 11

    listeInstructions              shift and go to state 107
    instruction                    shift and go to state 3
    type                           shift and go to state 4

state 102

    (8) instruction -> SI ( expr ) bloc . SINON bloc
    (9) instruction -> SI ( expr ) bloc .
    SINON           shift and go to state 108
    IDENTIFIANT     reduce using rule 9 (instruction -> SI ( expr ) bloc .)
    RETOURNER       reduce using rule 9 (instruction -> SI ( expr ) bloc .)
    TANTQUE         reduce using rule 9 (instruction -> SI ( expr ) bloc .)
    SI              reduce using rule 9 (instruction -> SI ( expr ) bloc .)
    ECRIRE          reduce using rule 9 (instruction -> SI ( expr ) bloc .)
    BOOLEEN_TYPE    reduce using rule 9 (instruction -> SI ( expr ) bloc .)
    ENTIER_TYPE     reduce using rule 9 (instruction -> SI ( expr ) bloc .)
    $end            reduce using rule 9 (instruction -> SI ( expr ) bloc .)
    }               reduce using rule 9 (instruction -> SI ( expr ) bloc .)


state 103

    (13) instruction -> ECRIRE ( CHAINE ) ; .
    IDENTIFIANT     reduce using rule 13 (instruction -> ECRIRE ( CHAINE ) ; .)
    RETOURNER       reduce using rule 13 (instruction -> ECRIRE ( CHAINE ) ; .)
    TANTQUE         reduce using rule 13 (instruction -> ECRIRE ( CHAINE ) ; .)
    SI              reduce using rule 13 (instruction -> ECRIRE ( CHAINE ) ; .)
    ECRIRE          reduce using rule 13 (instruction -> ECRIRE ( CHAINE ) ; .)
    BOOLEEN_TYPE    reduce using rule 13 (instruction -> ECRIRE ( CHAINE ) ; .)
    ENTIER_TYPE     reduce using rule 13 (instruction -> ECRIRE ( CHAINE ) ; .)
    $end            reduce using rule 13 (instruction -> ECRIRE ( CHAINE ) ; .)
    }               reduce using rule 13 (instruction -> ECRIRE ( CHAINE ) ; .)


state 104

    (14) instruction -> ECRIRE ( expr ) ; .
    IDENTIFIANT     reduce using rule 14 (instruction -> ECRIRE ( expr ) ; .)
    RETOURNER       reduce using rule 14 (instruction -> ECRIRE ( expr ) ; .)
    TANTQUE         reduce using rule 14 (instruction -> ECRIRE ( expr ) ; .)
    SI              reduce using rule 14 (instruction -> ECRIRE ( expr ) ; .)
    ECRIRE          reduce using rule 14 (instruction -> ECRIRE ( expr ) ; .)
    BOOLEEN_TYPE    reduce using rule 14 (instruction -> ECRIRE ( expr ) ; .)
    ENTIER_TYPE     reduce using rule 14 (instruction -> ECRIRE ( expr ) ; .)
    $end            reduce using rule 14 (instruction -> ECRIRE ( expr ) ; .)
    }               reduce using rule 14 (instruction -> ECRIRE ( expr ) ; .)


state 105

    (4) instruction -> type IDENTIFIANT ( listeParamsOpt ) bloc .
    IDENTIFIANT     reduce using rule 4 (instruction -> type IDENTIFIANT ( listeParamsOpt ) bloc .)
    RETOURNER       reduce using rule 4 (instruction -> type IDENTIFIANT ( listeParamsOpt ) bloc .)
    TANTQUE         reduce using rule 4 (instruction -> type IDENTIFIANT ( listeParamsOpt ) bloc .)
    SI              reduce using rule 4 (instruction -> type IDENTIFIANT ( listeParamsOpt ) bloc .)
    ECRIRE          reduce using rule 4 (instruction -> type IDENTIFIANT ( listeParamsOpt ) bloc .)
    BOOLEEN_TYPE    reduce using rule 4 (instruction -> type IDENTIFIANT ( listeParamsOpt ) bloc .)
    ENTIER_TYPE     reduce using rule 4 (instruction -> type IDENTIFIANT ( listeParamsOpt ) bloc .)
    $end            reduce using rule 4 (instruction -> type IDENTIFIANT ( listeParamsOpt ) bloc .)
    }               reduce using rule 4 (instruction -> type IDENTIFIANT ( listeParamsOpt ) bloc .)


state 106

    (54) listeParams -> listeParams , type . IDENTIFIANT
    IDENTIFIANT     shift and go to state 109


state 107

    (47) bloc -> { listeInstructions . }
    }               shift and go to state 110


state 108

    (8) instruction -> SI ( expr ) bloc SINON . bloc
    (47) bloc -> . { listeInstructions }
    {               shift and go to state 101

    bloc                           shift and go to state 111

state 109

    (54) listeParams -> listeParams , type IDENTIFIANT .
    ,               reduce using rule 54 (listeParams -> listeParams , type IDENTIFIANT .)
    )               reduce using rule 54 (listeParams -> listeParams , type IDENTIFIANT .)


state 110

    (47) bloc -> { listeInstructions } .
    IDENTIFIANT     reduce using rule 47 (bloc -> { listeInstructions } .)
    RETOURNER       reduce using rule 47 (bloc -> { listeInstructions } .)
    TANTQUE         reduce using rule 47 (bloc -> { listeInstructions } .)
    SI              reduce using rule 47 (bloc -> { listeInstructions } .)
    ECRIRE          reduce using rule 47 (bloc -> { listeInstructions } .)
    BOOLEEN_TYPE    reduce using rule 47 (bloc -> { listeInstructions } .)
    ENTIER_TYPE     reduce using rule 47 (bloc -> { listeInstructions } .)
    $end            reduce using rule 47 (bloc -> { listeInstructions } .)
    }               reduce using rule 47 (bloc -> { listeInstructions } .)
    SINON           reduce using rule 47 (bloc -> { listeInstructions } .)


state 111

    (8) instruction -> SI ( expr ) bloc SINON bloc .
    IDENTIFIANT     reduce using rule 8 (instruction -> SI ( expr ) bloc SINON bloc .)
    RETOURNER       reduce using rule 8 (instruction -> SI ( expr ) bloc SINON bloc .)
    TANTQUE         reduce using rule 8 (instruction -> SI ( expr ) bloc SINON bloc .)
    SI              reduce using rule 8 (instruction -> SI ( expr ) bloc SINON bloc .)
    ECRIRE          reduce using rule 8 (instruction -> SI ( expr ) bloc SINON bloc .)
    BOOLEEN_TYPE    reduce using rule 8 (instruction -> SI ( expr ) bloc SINON bloc .)
    ENTIER_TYPE     reduce using rule 8 (instruction -> SI ( expr ) bloc SINON bloc .)
    $end            reduce using rule 8 (instruction -> SI ( expr ) bloc SINON bloc .)
    }               reduce using rule 8 (instruction -> SI ( expr ) bloc SINON bloc .)
